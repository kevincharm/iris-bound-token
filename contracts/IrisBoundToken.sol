// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8;

import {IERC721, ERC721, ERC721Enumerable} from "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import {IWorldID} from "./vendor/IWorldID.sol";

/// @title IrisBoundToken
/// @author kevincharm, maggo, Nico Gallardo
/// @notice A non-transferrable token that is bound to a person's Iris. Verifies proofs-of-personhood via WorldID
///     and allows a person to reclaim an IBT onto a new address if their current address ever gets compromised.
contract IrisBoundToken is ERC721Enumerable {
    /// @notice WorldID instance
    IWorldID public immutable worldId;
    /// @notice WorldID group, always 1
    uint256 public immutable groupId;
    /// @notice Mapping of nullifier hash to tokenId.
    mapping(uint256 => uint256) public nullifierHashToTokenId;
    /// @notice A mapping that keeps track of whether an address has ever owned an IrisBoundToken.
    ///     An address can only own an IBT once, so as to prevent a malicious user from replaying
    ///     a proof that can steal back an IBT.
    mapping(address => bool) public addressHasBeenUsed;

    constructor(IWorldID worldId_, uint256 groupId_)
        ERC721("Iris-Bound Token", "IBT")
    {
        worldId = worldId_;
        groupId = groupId_;
    }

    /// @notice Hash any bytes input and truncate to finite field
    /// @param whatever whatever u want man
    function hash(bytes memory whatever) private pure returns (uint256) {
        return uint256(keccak256(abi.encodePacked(whatever))) >> 8;
    }

    /// @notice Verify proof of membership in a WorldID instance, while also ensuring that an
    ///     address can only ever own an IBT once.
    /// @param destination Destination address of the IBT
    /// @param worldIdRoot Merkle root of the WorldID instance (provided by prover)
    /// @param nullifierHash Nullifier hash that stays constant per [person, actionId] (provided by prover)
    /// @param proof SNARK proof
    function verifyProofAndRecord(
        address destination,
        uint256 worldIdRoot,
        uint256 nullifierHash,
        uint256[8] calldata proof
    ) private {
        // Address can only own an IBT once
        require(
            !addressHasBeenUsed[destination],
            "This address has previously owned an IBT!"
        );
        addressHasBeenUsed[destination] = true;

        worldId.verifyProof(
            worldIdRoot,
            groupId,
            hash(abi.encodePacked(destination)), /** signal */
            nullifierHash,
            hash(abi.encodePacked(address(this))), /** actionId */
            proof
        );
    }

    /// @notice Mint a non-transferrable, iris-bound NFT by providing proof of personhood
    ///     via WorldID.
    /// @param worldIdRoot Merkle root of the WorldID instance (provided by prover)
    /// @param nullifierHash Nullifier hash that stays constant per [person, actionId] (provided by prover)
    /// @param proof SNARK proof
    function mint(
        uint256 worldIdRoot,
        uint256 nullifierHash,
        uint256[8] calldata proof
    ) external {
        require(
            nullifierHashToTokenId[nullifierHash] == 0,
            "You already minted with your iris!"
        );

        // This user has not minted before, so now we check validity of the proof
        verifyProofAndRecord(msg.sender, worldIdRoot, nullifierHash, proof);

        // Proof is valid at this point, so we mint a token to the caller's address
        uint256 tokenId = totalSupply() + 1;
        // Assign this tokenId to the generator of this nullifierHash. Further proofs
        // generated by this person will be accompanied by the same nullifierHash, so we
        // know that certain proofs are generated by certain persons.
        nullifierHashToTokenId[nullifierHash] = tokenId;

        _safeMint(msg.sender, tokenId);
    }

    /// @notice Reclaim the token from the current owner by providing proof that the caller is
    ///     indeed the same person that owns that token.
    /// @param worldIdRoot Merkle root of the WorldID instance (provided by prover)
    /// @param nullifierHash Nullifier hash that stays constant per [person, actionId] (provided by prover)
    /// @param proof SNARK proof
    function reclaim(
        uint256 worldIdRoot,
        uint256 nullifierHash,
        uint256[8] calldata proof
    ) external {
        require(
            nullifierHashToTokenId[nullifierHash] != 0,
            "You have not minted a token yet"
        );

        // Ensure validity of proof and that the caller has never owned an IBT
        verifyProofAndRecord(msg.sender, worldIdRoot, nullifierHash, proof);

        // Recover the tokenId that this person owns
        uint256 tokenId = nullifierHashToTokenId[nullifierHash];
        address currentOwner = ownerOf(tokenId);
        // Transfer the IBT from the current owner to the caller
        _safeTransfer(currentOwner, msg.sender, tokenId, bytes(""));
    }

    /// @dev TODO
    function tokenURI(uint256 tokenId)
        public
        view
        override
        returns (string memory)
    {
        return "";
    }

    /// @notice Modified `transferFrom` implementation that deviates from ERC-721: tokens
    ///     are generally non-transferrable, unless the owner of the tokenId is "reclaiming"
    ///     this token onto a new account.
    function transferFrom(
        address,
        address,
        uint256
    ) public pure override(IERC721, ERC721) {
        revert("Token is non-transferrable");
    }

    /// @notice Modified `safeTransferFrom` implementation that deviates from ERC-721: tokens
    ///     are generally non-transferrable, unless the owner of the tokenId is "reclaiming"
    ///     this token onto a new account.
    function safeTransferFrom(
        address,
        address,
        uint256,
        bytes memory
    ) public pure override(IERC721, ERC721) {
        revert("Token is non-transferrable");
    }
}
